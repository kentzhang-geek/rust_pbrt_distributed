// automatically generated by the FlatBuffers compiler, do not modify



use crate::common::*;
use crate::texture::*;
use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod sf {

  use crate::common::*;
  use crate::texture::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SURFACE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SURFACE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SURFACE: [Surface; 3] = [
  Surface::NONE,
  Surface::PhongSurface,
  Surface::LambertSurface,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Surface(pub u8);
#[allow(non_upper_case_globals)]
impl Surface {
  pub const NONE: Self = Self(0);
  pub const PhongSurface: Self = Self(1);
  pub const LambertSurface: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PhongSurface,
    Self::LambertSurface,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PhongSurface => Some("PhongSurface"),
      Self::LambertSurface => Some("LambertSurface"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Surface {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Surface {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Surface {
    type Output = Surface;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Surface {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Surface {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Surface {}
pub struct SurfaceUnionTableOffset {}

#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum SurfaceT {
  NONE,
  PhongSurface(Box<PhongSurfaceT>),
  LambertSurface(Box<LambertSurfaceT>),
}
impl Default for SurfaceT {
  fn default() -> Self {
    Self::NONE
  }
}
impl SurfaceT {
  pub fn surface_type(&self) -> Surface {
    match self {
      Self::NONE => Surface::NONE,
      Self::PhongSurface(_) => Surface::PhongSurface,
      Self::LambertSurface(_) => Surface::LambertSurface,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::PhongSurface(v) => Some(v.pack(fbb).as_union_value()),
      Self::LambertSurface(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned PhongSurfaceT, setting the union to NONE.
  pub fn take_phong_surface(&mut self) -> Option<Box<PhongSurfaceT>> {
    if let Self::PhongSurface(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::PhongSurface(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PhongSurfaceT.
  pub fn as_phong_surface(&self) -> Option<&PhongSurfaceT> {
    if let Self::PhongSurface(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PhongSurfaceT.
  pub fn as_phong_surface_mut(&mut self) -> Option<&mut PhongSurfaceT> {
    if let Self::PhongSurface(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LambertSurfaceT, setting the union to NONE.
  pub fn take_lambert_surface(&mut self) -> Option<Box<LambertSurfaceT>> {
    if let Self::LambertSurface(_) = self {
      let v = std::mem::replace(self, Self::NONE);
      if let Self::LambertSurface(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LambertSurfaceT.
  pub fn as_lambert_surface(&self) -> Option<&LambertSurfaceT> {
    if let Self::LambertSurface(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LambertSurfaceT.
  pub fn as_lambert_surface_mut(&mut self) -> Option<&mut LambertSurfaceT> {
    if let Self::LambertSurface(v) = self { Some(v.as_mut()) } else { None }
  }
}
pub enum LambertSurfaceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LambertSurface<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LambertSurface<'a> {
    type Inner = LambertSurface<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> LambertSurface<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LambertSurface { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LambertSurfaceArgs<'args>) -> flatbuffers::WIPOffset<LambertSurface<'bldr>> {
      let mut builder = LambertSurfaceBuilder::new(_fbb);
      if let Some(x) = args.roughness { builder.add_roughness(x); }
      if let Some(x) = args.metallic { builder.add_metallic(x); }
      if let Some(x) = args.normal_texture { builder.add_normal_texture(x); }
      if let Some(x) = args.normal { builder.add_normal(x); }
      if let Some(x) = args.ambient_texture { builder.add_ambient_texture(x); }
      if let Some(x) = args.ambient { builder.add_ambient(x); }
      if let Some(x) = args.emissive_texture { builder.add_emissive_texture(x); }
      if let Some(x) = args.emissive { builder.add_emissive(x); }
      if let Some(x) = args.albedo_texture { builder.add_albedo_texture(x); }
      if let Some(x) = args.albedo { builder.add_albedo(x); }
      if let Some(x) = args.diffuse_texture { builder.add_diffuse_texture(x); }
      if let Some(x) = args.diffuse { builder.add_diffuse(x); }
      builder.finish()
    }

    pub fn unpack(&self) -> LambertSurfaceT {
      let diffuse = self.diffuse().map(|x| {
        x.unpack()
      });
      let diffuse_texture = self.diffuse_texture().map(|x| {
        Box::new(x.unpack())
      });
      let albedo = self.albedo().map(|x| {
        x.unpack()
      });
      let albedo_texture = self.albedo_texture().map(|x| {
        Box::new(x.unpack())
      });
      let emissive = self.emissive().map(|x| {
        x.unpack()
      });
      let emissive_texture = self.emissive_texture().map(|x| {
        Box::new(x.unpack())
      });
      let ambient = self.ambient().map(|x| {
        x.unpack()
      });
      let ambient_texture = self.ambient_texture().map(|x| {
        Box::new(x.unpack())
      });
      let normal = self.normal().map(|x| {
        x.unpack()
      });
      let normal_texture = self.normal_texture().map(|x| {
        Box::new(x.unpack())
      });
      let metallic = self.metallic().map(|x| {
        x.unpack()
      });
      let roughness = self.roughness().map(|x| {
        x.unpack()
      });
      LambertSurfaceT {
        diffuse,
        diffuse_texture,
        albedo,
        albedo_texture,
        emissive,
        emissive_texture,
        ambient,
        ambient_texture,
        normal,
        normal_texture,
        metallic,
        roughness,
      }
    }
    pub const VT_DIFFUSE: flatbuffers::VOffsetT = 4;
    pub const VT_DIFFUSE_TEXTURE: flatbuffers::VOffsetT = 6;
    pub const VT_ALBEDO: flatbuffers::VOffsetT = 8;
    pub const VT_ALBEDO_TEXTURE: flatbuffers::VOffsetT = 10;
    pub const VT_EMISSIVE: flatbuffers::VOffsetT = 12;
    pub const VT_EMISSIVE_TEXTURE: flatbuffers::VOffsetT = 14;
    pub const VT_AMBIENT: flatbuffers::VOffsetT = 16;
    pub const VT_AMBIENT_TEXTURE: flatbuffers::VOffsetT = 18;
    pub const VT_NORMAL: flatbuffers::VOffsetT = 20;
    pub const VT_NORMAL_TEXTURE: flatbuffers::VOffsetT = 22;
    pub const VT_METALLIC: flatbuffers::VOffsetT = 24;
    pub const VT_ROUGHNESS: flatbuffers::VOffsetT = 26;

  #[inline]
  pub fn diffuse(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(LambertSurface::VT_DIFFUSE, None)
  }
  #[inline]
  pub fn diffuse_texture(&self) -> Option<Texture<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Texture>>(LambertSurface::VT_DIFFUSE_TEXTURE, None)
  }
  #[inline]
  pub fn albedo(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(LambertSurface::VT_ALBEDO, None)
  }
  #[inline]
  pub fn albedo_texture(&self) -> Option<Texture<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Texture>>(LambertSurface::VT_ALBEDO_TEXTURE, None)
  }
  #[inline]
  pub fn emissive(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(LambertSurface::VT_EMISSIVE, None)
  }
  #[inline]
  pub fn emissive_texture(&self) -> Option<Texture<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Texture>>(LambertSurface::VT_EMISSIVE_TEXTURE, None)
  }
  #[inline]
  pub fn ambient(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(LambertSurface::VT_AMBIENT, None)
  }
  #[inline]
  pub fn ambient_texture(&self) -> Option<Texture<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Texture>>(LambertSurface::VT_AMBIENT_TEXTURE, None)
  }
  #[inline]
  pub fn normal(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(LambertSurface::VT_NORMAL, None)
  }
  #[inline]
  pub fn normal_texture(&self) -> Option<Texture<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Texture>>(LambertSurface::VT_NORMAL_TEXTURE, None)
  }
  #[inline]
  pub fn metallic(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(LambertSurface::VT_METALLIC, None)
  }
  #[inline]
  pub fn roughness(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(LambertSurface::VT_ROUGHNESS, None)
  }
}

impl flatbuffers::Verifiable for LambertSurface<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vec3d>(&"diffuse", Self::VT_DIFFUSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Texture>>(&"diffuse_texture", Self::VT_DIFFUSE_TEXTURE, false)?
     .visit_field::<Vec3d>(&"albedo", Self::VT_ALBEDO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Texture>>(&"albedo_texture", Self::VT_ALBEDO_TEXTURE, false)?
     .visit_field::<Vec3d>(&"emissive", Self::VT_EMISSIVE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Texture>>(&"emissive_texture", Self::VT_EMISSIVE_TEXTURE, false)?
     .visit_field::<Vec3d>(&"ambient", Self::VT_AMBIENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Texture>>(&"ambient_texture", Self::VT_AMBIENT_TEXTURE, false)?
     .visit_field::<Vec3d>(&"normal", Self::VT_NORMAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Texture>>(&"normal_texture", Self::VT_NORMAL_TEXTURE, false)?
     .visit_field::<Vec3d>(&"metallic", Self::VT_METALLIC, false)?
     .visit_field::<Vec3d>(&"roughness", Self::VT_ROUGHNESS, false)?
     .finish();
    Ok(())
  }
}
pub struct LambertSurfaceArgs<'a> {
    pub diffuse: Option<&'a Vec3d>,
    pub diffuse_texture: Option<flatbuffers::WIPOffset<Texture<'a>>>,
    pub albedo: Option<&'a Vec3d>,
    pub albedo_texture: Option<flatbuffers::WIPOffset<Texture<'a>>>,
    pub emissive: Option<&'a Vec3d>,
    pub emissive_texture: Option<flatbuffers::WIPOffset<Texture<'a>>>,
    pub ambient: Option<&'a Vec3d>,
    pub ambient_texture: Option<flatbuffers::WIPOffset<Texture<'a>>>,
    pub normal: Option<&'a Vec3d>,
    pub normal_texture: Option<flatbuffers::WIPOffset<Texture<'a>>>,
    pub metallic: Option<&'a Vec3d>,
    pub roughness: Option<&'a Vec3d>,
}
impl<'a> Default for LambertSurfaceArgs<'a> {
    #[inline]
    fn default() -> Self {
        LambertSurfaceArgs {
            diffuse: None,
            diffuse_texture: None,
            albedo: None,
            albedo_texture: None,
            emissive: None,
            emissive_texture: None,
            ambient: None,
            ambient_texture: None,
            normal: None,
            normal_texture: None,
            metallic: None,
            roughness: None,
        }
    }
}
pub struct LambertSurfaceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LambertSurfaceBuilder<'a, 'b> {
  #[inline]
  pub fn add_diffuse(&mut self, diffuse: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(LambertSurface::VT_DIFFUSE, diffuse);
  }
  #[inline]
  pub fn add_diffuse_texture(&mut self, diffuse_texture: flatbuffers::WIPOffset<Texture<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Texture>>(LambertSurface::VT_DIFFUSE_TEXTURE, diffuse_texture);
  }
  #[inline]
  pub fn add_albedo(&mut self, albedo: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(LambertSurface::VT_ALBEDO, albedo);
  }
  #[inline]
  pub fn add_albedo_texture(&mut self, albedo_texture: flatbuffers::WIPOffset<Texture<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Texture>>(LambertSurface::VT_ALBEDO_TEXTURE, albedo_texture);
  }
  #[inline]
  pub fn add_emissive(&mut self, emissive: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(LambertSurface::VT_EMISSIVE, emissive);
  }
  #[inline]
  pub fn add_emissive_texture(&mut self, emissive_texture: flatbuffers::WIPOffset<Texture<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Texture>>(LambertSurface::VT_EMISSIVE_TEXTURE, emissive_texture);
  }
  #[inline]
  pub fn add_ambient(&mut self, ambient: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(LambertSurface::VT_AMBIENT, ambient);
  }
  #[inline]
  pub fn add_ambient_texture(&mut self, ambient_texture: flatbuffers::WIPOffset<Texture<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Texture>>(LambertSurface::VT_AMBIENT_TEXTURE, ambient_texture);
  }
  #[inline]
  pub fn add_normal(&mut self, normal: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(LambertSurface::VT_NORMAL, normal);
  }
  #[inline]
  pub fn add_normal_texture(&mut self, normal_texture: flatbuffers::WIPOffset<Texture<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Texture>>(LambertSurface::VT_NORMAL_TEXTURE, normal_texture);
  }
  #[inline]
  pub fn add_metallic(&mut self, metallic: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(LambertSurface::VT_METALLIC, metallic);
  }
  #[inline]
  pub fn add_roughness(&mut self, roughness: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(LambertSurface::VT_ROUGHNESS, roughness);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LambertSurfaceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LambertSurfaceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LambertSurface<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for LambertSurface<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("LambertSurface");
      ds.field("diffuse", &self.diffuse());
      ds.field("diffuse_texture", &self.diffuse_texture());
      ds.field("albedo", &self.albedo());
      ds.field("albedo_texture", &self.albedo_texture());
      ds.field("emissive", &self.emissive());
      ds.field("emissive_texture", &self.emissive_texture());
      ds.field("ambient", &self.ambient());
      ds.field("ambient_texture", &self.ambient_texture());
      ds.field("normal", &self.normal());
      ds.field("normal_texture", &self.normal_texture());
      ds.field("metallic", &self.metallic());
      ds.field("roughness", &self.roughness());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LambertSurfaceT {
  pub diffuse: Option<Vec3dT>,
  pub diffuse_texture: Option<Box<TextureT>>,
  pub albedo: Option<Vec3dT>,
  pub albedo_texture: Option<Box<TextureT>>,
  pub emissive: Option<Vec3dT>,
  pub emissive_texture: Option<Box<TextureT>>,
  pub ambient: Option<Vec3dT>,
  pub ambient_texture: Option<Box<TextureT>>,
  pub normal: Option<Vec3dT>,
  pub normal_texture: Option<Box<TextureT>>,
  pub metallic: Option<Vec3dT>,
  pub roughness: Option<Vec3dT>,
}
impl Default for LambertSurfaceT {
  fn default() -> Self {
    Self {
      diffuse: None,
      diffuse_texture: None,
      albedo: None,
      albedo_texture: None,
      emissive: None,
      emissive_texture: None,
      ambient: None,
      ambient_texture: None,
      normal: None,
      normal_texture: None,
      metallic: None,
      roughness: None,
    }
  }
}
impl LambertSurfaceT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LambertSurface<'b>> {
    let diffuse_tmp = self.diffuse.as_ref().map(|x| x.pack());
    let diffuse = diffuse_tmp.as_ref();
    let diffuse_texture = self.diffuse_texture.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let albedo_tmp = self.albedo.as_ref().map(|x| x.pack());
    let albedo = albedo_tmp.as_ref();
    let albedo_texture = self.albedo_texture.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let emissive_tmp = self.emissive.as_ref().map(|x| x.pack());
    let emissive = emissive_tmp.as_ref();
    let emissive_texture = self.emissive_texture.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ambient_tmp = self.ambient.as_ref().map(|x| x.pack());
    let ambient = ambient_tmp.as_ref();
    let ambient_texture = self.ambient_texture.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let normal_tmp = self.normal.as_ref().map(|x| x.pack());
    let normal = normal_tmp.as_ref();
    let normal_texture = self.normal_texture.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let metallic_tmp = self.metallic.as_ref().map(|x| x.pack());
    let metallic = metallic_tmp.as_ref();
    let roughness_tmp = self.roughness.as_ref().map(|x| x.pack());
    let roughness = roughness_tmp.as_ref();
    LambertSurface::create(_fbb, &LambertSurfaceArgs{
      diffuse,
      diffuse_texture,
      albedo,
      albedo_texture,
      emissive,
      emissive_texture,
      ambient,
      ambient_texture,
      normal,
      normal_texture,
      metallic,
      roughness,
    })
  }
}
pub enum PhongSurfaceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PhongSurface<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PhongSurface<'a> {
    type Inner = PhongSurface<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> PhongSurface<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PhongSurface { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PhongSurfaceArgs<'args>) -> flatbuffers::WIPOffset<PhongSurface<'bldr>> {
      let mut builder = PhongSurfaceBuilder::new(_fbb);
      if let Some(x) = args.base { builder.add_base(x); }
      if let Some(x) = args.specular_texture { builder.add_specular_texture(x); }
      if let Some(x) = args.specular { builder.add_specular(x); }
      builder.finish()
    }

    pub fn unpack(&self) -> PhongSurfaceT {
      let specular = self.specular().map(|x| {
        x.unpack()
      });
      let specular_texture = self.specular_texture().map(|x| {
        Box::new(x.unpack())
      });
      let base = self.base().map(|x| {
        Box::new(x.unpack())
      });
      PhongSurfaceT {
        specular,
        specular_texture,
        base,
      }
    }
    pub const VT_SPECULAR: flatbuffers::VOffsetT = 4;
    pub const VT_SPECULAR_TEXTURE: flatbuffers::VOffsetT = 6;
    pub const VT_BASE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn specular(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(PhongSurface::VT_SPECULAR, None)
  }
  #[inline]
  pub fn specular_texture(&self) -> Option<Texture<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Texture>>(PhongSurface::VT_SPECULAR_TEXTURE, None)
  }
  #[inline]
  pub fn base(&self) -> Option<LambertSurface<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<LambertSurface>>(PhongSurface::VT_BASE, None)
  }
}

impl flatbuffers::Verifiable for PhongSurface<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vec3d>(&"specular", Self::VT_SPECULAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Texture>>(&"specular_texture", Self::VT_SPECULAR_TEXTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LambertSurface>>(&"base", Self::VT_BASE, false)?
     .finish();
    Ok(())
  }
}
pub struct PhongSurfaceArgs<'a> {
    pub specular: Option<&'a Vec3d>,
    pub specular_texture: Option<flatbuffers::WIPOffset<Texture<'a>>>,
    pub base: Option<flatbuffers::WIPOffset<LambertSurface<'a>>>,
}
impl<'a> Default for PhongSurfaceArgs<'a> {
    #[inline]
    fn default() -> Self {
        PhongSurfaceArgs {
            specular: None,
            specular_texture: None,
            base: None,
        }
    }
}
pub struct PhongSurfaceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PhongSurfaceBuilder<'a, 'b> {
  #[inline]
  pub fn add_specular(&mut self, specular: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(PhongSurface::VT_SPECULAR, specular);
  }
  #[inline]
  pub fn add_specular_texture(&mut self, specular_texture: flatbuffers::WIPOffset<Texture<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Texture>>(PhongSurface::VT_SPECULAR_TEXTURE, specular_texture);
  }
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<LambertSurface<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LambertSurface>>(PhongSurface::VT_BASE, base);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PhongSurfaceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PhongSurfaceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PhongSurface<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for PhongSurface<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("PhongSurface");
      ds.field("specular", &self.specular());
      ds.field("specular_texture", &self.specular_texture());
      ds.field("base", &self.base());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PhongSurfaceT {
  pub specular: Option<Vec3dT>,
  pub specular_texture: Option<Box<TextureT>>,
  pub base: Option<Box<LambertSurfaceT>>,
}
impl Default for PhongSurfaceT {
  fn default() -> Self {
    Self {
      specular: None,
      specular_texture: None,
      base: None,
    }
  }
}
impl PhongSurfaceT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PhongSurface<'b>> {
    let specular_tmp = self.specular.as_ref().map(|x| x.pack());
    let specular = specular_tmp.as_ref();
    let specular_texture = self.specular_texture.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let base = self.base.as_ref().map(|x|{
      x.pack(_fbb)
    });
    PhongSurface::create(_fbb, &PhongSurfaceArgs{
      specular,
      specular_texture,
      base,
    })
  }
}
pub enum MaterialOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Material<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Material<'a> {
    type Inner = Material<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Material<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Material { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MaterialArgs<'args>) -> flatbuffers::WIPOffset<Material<'bldr>> {
      let mut builder = MaterialBuilder::new(_fbb);
      builder.add_id(args.id);
      if let Some(x) = args.surface { builder.add_surface(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_surface_type(args.surface_type);
      builder.finish()
    }

    pub fn unpack(&self) -> MaterialT {
      let id = self.id();
      let name = self.name().map(|x| {
        x.to_string()
      });
      let surface = match self.surface_type() {
        Surface::NONE => SurfaceT::NONE,
        Surface::PhongSurface => SurfaceT::PhongSurface(Box::new(
          self.surface_as_phong_surface()
              .expect("Invalid union table, expected `Surface::PhongSurface`.")
              .unpack()
        )),
        Surface::LambertSurface => SurfaceT::LambertSurface(Box::new(
          self.surface_as_lambert_surface()
              .expect("Invalid union table, expected `Surface::LambertSurface`.")
              .unpack()
        )),
        _ => SurfaceT::NONE,
      };
      MaterialT {
        id,
        name,
        surface,
      }
    }
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_SURFACE_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_SURFACE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn id(&self) -> u64 {
    self._tab.get::<u64>(Material::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_NAME, None)
  }
  #[inline]
  pub fn surface_type(&self) -> Surface {
    self._tab.get::<Surface>(Material::VT_SURFACE_TYPE, Some(Surface::NONE)).unwrap()
  }
  #[inline]
  pub fn surface(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Material::VT_SURFACE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn surface_as_phong_surface(&self) -> Option<PhongSurface<'a>> {
    if self.surface_type() == Surface::PhongSurface {
      self.surface().map(PhongSurface::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn surface_as_lambert_surface(&self) -> Option<LambertSurface<'a>> {
    if self.surface_type() == Surface::LambertSurface {
      self.surface().map(LambertSurface::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Material<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_union::<Surface, _>(&"surface_type", Self::VT_SURFACE_TYPE, &"surface", Self::VT_SURFACE, false, |key, v, pos| {
        match key {
          Surface::PhongSurface => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PhongSurface>>("Surface::PhongSurface", pos),
          Surface::LambertSurface => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LambertSurface>>("Surface::LambertSurface", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct MaterialArgs<'a> {
    pub id: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub surface_type: Surface,
    pub surface: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MaterialArgs<'a> {
    #[inline]
    fn default() -> Self {
        MaterialArgs {
            id: 0,
            name: None,
            surface_type: Surface::NONE,
            surface: None,
        }
    }
}
pub struct MaterialBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MaterialBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(Material::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_NAME, name);
  }
  #[inline]
  pub fn add_surface_type(&mut self, surface_type: Surface) {
    self.fbb_.push_slot::<Surface>(Material::VT_SURFACE_TYPE, surface_type, Surface::NONE);
  }
  #[inline]
  pub fn add_surface(&mut self, surface: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_SURFACE, surface);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MaterialBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MaterialBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Material<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Material<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Material");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("surface_type", &self.surface_type());
      match self.surface_type() {
        Surface::PhongSurface => {
          if let Some(x) = self.surface_as_phong_surface() {
            ds.field("surface", &x)
          } else {
            ds.field("surface", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Surface::LambertSurface => {
          if let Some(x) = self.surface_as_lambert_surface() {
            ds.field("surface", &x)
          } else {
            ds.field("surface", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("surface", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MaterialT {
  pub id: u64,
  pub name: Option<String>,
  pub surface: SurfaceT,
}
impl Default for MaterialT {
  fn default() -> Self {
    Self {
      id: 0,
      name: None,
      surface: SurfaceT::NONE,
    }
  }
}
impl MaterialT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Material<'b>> {
    let id = self.id;
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let surface_type = self.surface.surface_type();
    let surface = self.surface.pack(_fbb);
    Material::create(_fbb, &MaterialArgs{
      id,
      name,
      surface_type,
      surface,
    })
  }
}
}  // pub mod sf

